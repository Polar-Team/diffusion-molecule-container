name: Scheduled AI Dockerfile Updater

on:
  schedule:
    - cron: '0 8 * * 1' # Every Monday at 8:00 AM UTC
  workflow_dispatch:

jobs:
  ai-update:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      models: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # ── Step 1: Resolve latest versions from upstream ──────────────────────
      - name: Resolve latest versions
        id: versions
        run: |
          # Docker DinD — latest tag matching *-dind-alpine3.23
          DIND=$(curl -sS "https://hub.docker.com/v2/repositories/library/docker/tags/?page_size=100" \
            | jq -r '.results[].name' \
            | grep -E '^[0-9]+\.[0-9]+\.[0-9]+-dind-alpine3\.23$' \
            | sort -V | tail -1)
          echo "dind=$DIND" >> $GITHUB_OUTPUT
          echo "Resolved DinD: $DIND"

          # uv — latest release from GitHub (stay on current minor 0.9.x to avoid breaking changes)
          CURRENT_UV=$(grep 'UV_VERSION' Dockerfile | head -1 | grep -oP '[\d]+\.[\d]+\.[\d]+')
          CURRENT_UV_MINOR=$(echo "$CURRENT_UV" | cut -d. -f1-2)
          UV=$(curl -sS "https://api.github.com/repos/astral-sh/uv/releases?per_page=50" \
            | jq -r '.[].tag_name' \
            | grep -E "^${CURRENT_UV_MINOR}\." \
            | sort -V | tail -1)
          echo "uv=$UV" >> $GITHUB_OUTPUT
          echo "Resolved uv: $UV"

          # Python versions — latest patch for each minor in use
          CURRENT_VERSIONS=$(grep 'PYTHON_VERSIONS' Dockerfile | head -1 | grep -oP '[\d]+\.[\d]+\.[\d]+' | tr '\n' ' ')
          echo "Current Python versions: $CURRENT_VERSIONS"

          PYTHON_RELEASES=$(curl -sS "https://www.python.org/api/v2/downloads/release/?format=json&limit=200&ordering=-name")
          UPDATED_VERSIONS=""
          for VER in $CURRENT_VERSIONS; do
            MINOR=$(echo "$VER" | cut -d. -f1-2)
            LATEST=$(echo "$PYTHON_RELEASES" \
              | jq -r '.[].name' \
              | grep -E "^Python ${MINOR//./\\.}\.[0-9]+$" \
              | grep -oP "${MINOR//./\\.}\.[0-9]+" \
              | sort -V | tail -1)
            if [ -z "$LATEST" ]; then
              LATEST=$VER
            fi
            UPDATED_VERSIONS="$UPDATED_VERSIONS $LATEST"
          done
          UPDATED_VERSIONS=$(echo "$UPDATED_VERSIONS" | xargs)  # trim whitespace
          echo "python_versions=$UPDATED_VERSIONS" >> $GITHUB_OUTPUT
          echo "Resolved Python versions: $UPDATED_VERSIONS"

          # Alpine package versions — fetch each from pkgs.alpinelinux.org
          fetch_apk_version() {
            curl --max-time 10 -sS "https://pkgs.alpinelinux.org/package/v3.23/main/x86_64/$1" \
              | grep -A3 'class="header">Version' \
              | grep -oP '(?<=<strong>)[\d]+\.[\d.]+(-r[\d]+)?(?=</strong>)' | head -1
          }

          OPENSSL_VER=$(fetch_apk_version openssl)
          OPENSSL_DEV_VER=$(fetch_apk_version openssl-dev)
          GIT_VER=$(fetch_apk_version git)
          CURL_VER=$(fetch_apk_version curl)
          BASH_VER=$(fetch_apk_version bash)
          GCC_VER=$(fetch_apk_version gcc)
          MUSL_VER=$(fetch_apk_version musl)
          LIBFFI_VER=$(fetch_apk_version libffi)
          MAKE_VER=$(fetch_apk_version make)
          BZIP2_VER=$(fetch_apk_version bzip2)
          ZLIB_VER=$(fetch_apk_version zlib)
          READLINE_VER=$(fetch_apk_version readline)
          SQLITE_VER=$(fetch_apk_version sqlite-dev)
          XZ_VER=$(fetch_apk_version xz)
          TK_VER=$(fetch_apk_version tk)
          PATCH_VER=$(fetch_apk_version patch)

          echo "openssl=$OPENSSL_VER"           >> $GITHUB_OUTPUT
          echo "openssl_dev=$OPENSSL_DEV_VER"   >> $GITHUB_OUTPUT
          echo "git=$GIT_VER"                   >> $GITHUB_OUTPUT
          echo "curl=$CURL_VER"                 >> $GITHUB_OUTPUT
          echo "bash=$BASH_VER"                 >> $GITHUB_OUTPUT
          echo "gcc=$GCC_VER"                   >> $GITHUB_OUTPUT
          echo "musl=$MUSL_VER"                 >> $GITHUB_OUTPUT
          echo "libffi=$LIBFFI_VER"             >> $GITHUB_OUTPUT
          echo "make=$MAKE_VER"                 >> $GITHUB_OUTPUT
          echo "bzip2=$BZIP2_VER"               >> $GITHUB_OUTPUT
          echo "zlib=$ZLIB_VER"                 >> $GITHUB_OUTPUT
          echo "readline=$READLINE_VER"         >> $GITHUB_OUTPUT
          echo "sqlite=$SQLITE_VER"             >> $GITHUB_OUTPUT
          echo "xz=$XZ_VER"                     >> $GITHUB_OUTPUT
          echo "tk=$TK_VER"                     >> $GITHUB_OUTPUT
          echo "patch=$PATCH_VER"               >> $GITHUB_OUTPUT

          echo "All versions resolved."

      # ── Step 2: Use AI to apply the resolved versions to the Dockerfile ────
      - name: Apply updates via GitHub Models AI
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          DOCKERFILE=$(cat Dockerfile)

          VERSIONS_SUMMARY="Resolved latest versions to apply:
          - DIND_VERSION: ${{ steps.versions.outputs.dind }}
          - UV_VERSION: ${{ steps.versions.outputs.uv }}
          - PYTHON_VERSIONS: ${{ steps.versions.outputs.python_versions }}
          - git: ${{ steps.versions.outputs.git }}
          - curl: ${{ steps.versions.outputs.curl }}
          - bash: ${{ steps.versions.outputs.bash }}
          - gcc: ${{ steps.versions.outputs.gcc }}
          - musl / musl-dev: ${{ steps.versions.outputs.musl }}
          - libffi / libffi-dev: ${{ steps.versions.outputs.libffi }}
          - make: ${{ steps.versions.outputs.make }}
          - openssl / openssl-dev: ${{ steps.versions.outputs.openssl }}
          - bzip2 / bzip2-dev: ${{ steps.versions.outputs.bzip2 }}
          - zlib / zlib-dev: ${{ steps.versions.outputs.zlib }}
          - readline / readline-dev: ${{ steps.versions.outputs.readline }}
          - sqlite-dev: ${{ steps.versions.outputs.sqlite }}
          - xz / xz-dev: ${{ steps.versions.outputs.xz }}
          - tk / tk-dev: ${{ steps.versions.outputs.tk }}
          - patch: ${{ steps.versions.outputs.patch }}"

          echo "$VERSIONS_SUMMARY"

          PAYLOAD=$(jq -n \
            --arg dockerfile "$DOCKERFILE" \
            --arg versions "$VERSIONS_SUMMARY" \
            '{
              model: "openai/gpt-4o",
              temperature: 0,
              max_tokens: 4096,
              messages: [
                {
                  role: "system",
                  content: "You are a Dockerfile editor. You receive a Dockerfile and a list of new package versions. You update the version pins in the Dockerfile to match the provided versions exactly. You output ONLY the raw updated Dockerfile — no markdown fences, no explanation, no extra text."
                },
                {
                  role: "user",
                  content: ("Update the following Dockerfile by replacing all version pins with the exact versions listed below. Do not change anything else.\n\n" + $versions + "\n\nDockerfile:\n\n" + $dockerfile)
                }
              ]
            }')

          RESPONSE=$(curl -sS \
            -X POST "https://models.github.ai/inference/chat/completions" \
            -H "Authorization: Bearer $GH_TOKEN" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD")

          echo "--- RAW API RESPONSE ---"
          echo "$RESPONSE"
          echo "--- END RAW API RESPONSE ---"

          if echo "$RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
            echo "API error: $(echo "$RESPONSE" | jq -r '.error.message')"
            exit 1
          fi

          CONTENT=$(echo "$RESPONSE" | jq -r '.choices[0].message.content // empty')

          if [ -z "$CONTENT" ]; then
            echo "ERROR: Empty content. Full response structure:"
            echo "$RESPONSE" | jq '.'
            exit 1
          fi

          echo "--- RAW MODEL RESPONSE ---"
          echo "$CONTENT"
          echo "--- END RAW RESPONSE ---"

          # Strip markdown fences (```dockerfile, ```docker, ``` etc.) and leading/trailing blank lines
          echo "$CONTENT" \
            | sed 's/^[[:space:]]*//' \
            | grep -v '^```' \
            | grep -v '^~~~' > Dockerfile.new

          # Validate: must contain ARG or FROM anywhere in the file
          if grep -qE '(ARG|FROM)' Dockerfile.new && [ -s Dockerfile.new ]; then
            mv Dockerfile.new Dockerfile
            echo "Dockerfile updated successfully."
          else
            echo "ERROR: Response does not look like a valid Dockerfile."
            echo "Content of Dockerfile.new:"
            cat Dockerfile.new
            exit 1
          fi

          # Generate reasoning from the diff
          DIFF=$(git diff Dockerfile)
          if [ -n "$DIFF" ]; then
            REASONING_PAYLOAD=$(jq -n --arg diff "$DIFF" '{
              model: "openai/gpt-4o",
              temperature: 0,
              max_tokens: 512,
              messages: [{
                role: "user",
                content: ("Summarize in a short bullet list what version pins changed in this Dockerfile diff:\n\n" + $diff)
              }]
            }')
            curl -sS \
              -X POST "https://models.github.ai/inference/chat/completions" \
              -H "Authorization: Bearer $GH_TOKEN" \
              -H "Content-Type: application/json" \
              -d "$REASONING_PAYLOAD" \
              | jq -r '.choices[0].message.content // "No reasoning available."' > agent_reasoning.txt
          else
            echo "No changes in Dockerfile." > agent_reasoning.txt
          fi

      # ── Step 3: Commit, push, open PR ──────────────────────────────────────
      - name: Check for changes
        id: check_changes
        run: |
          if [[ -n "$(git status --porcelain Dockerfile)" ]]; then
            echo "changes_exist=true" >> $GITHUB_ENV
          else
            echo "changes_exist=false" >> $GITHUB_ENV
            echo "No changes detected — Dockerfile is already up to date."
          fi

      - name: Commit and push branch
        if: env.changes_exist == 'true'
        run: |
          BRANCH_NAME="ai-dockerfile-update-$(date +%Y%m%d-%H%M)"
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git checkout -b "$BRANCH_NAME"
          git add Dockerfile
          git commit -m "chore(docker): AI proposed dependency updates"
          git push origin "$BRANCH_NAME"
          echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_ENV

      - name: Create pull request
        if: env.changes_exist == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          REASONING=$(cat agent_reasoning.txt 2>/dev/null || echo "No reasoning available.")
          PR_BODY=$(cat <<EOF
          ## AI Dockerfile Dependency Update

          Automatically generated by the scheduled AI updater (GitHub Models / gpt-4o).
          Versions were resolved from upstream sources; AI applied them to the Dockerfile.

          ### Changes summary:
          ${REASONING}

          ---
          > Review the diff carefully before merging.
          EOF
          )

          gh pr create \
            --title "chore(docker): AI dependency updates ($(date +%Y-%m-%d))" \
            --body "$PR_BODY" \
            --base main \
            --head "${{ env.BRANCH_NAME }}"
