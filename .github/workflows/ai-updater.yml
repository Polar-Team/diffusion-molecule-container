name: Scheduled AI Dockerfile Updater

on:
  schedule:
    - cron: '0 8 * * 1' # Every Monday at 8:00 AM UTC
  workflow_dispatch:

jobs:
  ai-update:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      models: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # ── Step 1: Resolve latest versions from upstream ──────────────────────
      - name: Resolve latest versions
        id: versions
        run: |
          echo "::group::Resolving upstream versions"

          # Docker DinD — latest tag matching *-dind-alpine3.23
          DIND=$(curl --max-time 30 --connect-timeout 10 -sS \
            "https://hub.docker.com/v2/repositories/library/docker/tags/?page_size=100" \
            | jq -r '.results[].name' \
            | grep -E '^[0-9]+\.[0-9]+\.[0-9]+-dind-alpine3\.23$' \
            | sort -V | tail -1)
          if [ -z "$DIND" ]; then
            echo "::error::Failed to resolve DinD version from Docker Hub"
            exit 1
          fi
          echo "dind=$DIND" >> $GITHUB_OUTPUT
          echo "Resolved DinD: $DIND"

          # uv — latest release from GitHub (stay on current minor to avoid breaking changes)
          CURRENT_UV=$(grep 'UV_VERSION' Dockerfile | head -1 | grep -oP '[\d]+\.[\d]+\.[\d]+')
          CURRENT_UV_MINOR=$(echo "$CURRENT_UV" | cut -d. -f1-2)
          echo "Current uv: $CURRENT_UV (minor series: $CURRENT_UV_MINOR)"
          UV=$(curl --max-time 30 --connect-timeout 10 -sS \
            "https://api.github.com/repos/astral-sh/uv/releases?per_page=50" \
            | jq -r '.[].tag_name' \
            | grep -E "^${CURRENT_UV_MINOR}\." \
            | sort -V | tail -1)
          if [ -z "$UV" ]; then
            UV=$CURRENT_UV
            echo "::warning::Could not resolve uv version, keeping current: $UV"
          fi
          echo "uv=$UV" >> $GITHUB_OUTPUT
          echo "Resolved uv: $UV"

          # Python versions — latest patch for each minor in use
          CURRENT_VERSIONS=$(grep 'PYTHON_VERSIONS' Dockerfile | head -1 | grep -oP '[\d]+\.[\d]+\.[\d]+' | tr '\n' ' ')
          echo "Current Python versions: $CURRENT_VERSIONS"

          PYTHON_RELEASES=$(curl --max-time 30 --connect-timeout 10 -sS \
            "https://www.python.org/api/v2/downloads/release/?format=json&limit=200&ordering=-name")
          UPDATED_VERSIONS=""
          for VER in $CURRENT_VERSIONS; do
            MINOR=$(echo "$VER" | cut -d. -f1-2)
            LATEST=$(echo "$PYTHON_RELEASES" \
              | jq -r '.[].name' \
              | grep -E "^Python ${MINOR//./\\.}\.[0-9]+$" \
              | grep -oP "${MINOR//./\\.}\.[0-9]+" \
              | sort -V | tail -1)
            if [ -z "$LATEST" ]; then
              LATEST=$VER
            fi
            UPDATED_VERSIONS="$UPDATED_VERSIONS $LATEST"
          done
          UPDATED_VERSIONS=$(echo "$UPDATED_VERSIONS" | xargs)  # trim whitespace
          echo "python_versions=$UPDATED_VERSIONS" >> $GITHUB_OUTPUT
          echo "Resolved Python versions: $UPDATED_VERSIONS"

          # Alpine package versions — fetch each from pkgs.alpinelinux.org
          fetch_apk_version() {
            local pkg="$1"
            local ver
            ver=$(curl --max-time 10 --connect-timeout 5 -sS \
              "https://pkgs.alpinelinux.org/package/v3.23/main/x86_64/$pkg" \
              | grep -A3 'class="header">Version' \
              | grep -oP '(?<=<strong>)[\d]+\.[\d.]+(-r[\d]+)?(?=</strong>)' | head -1)
            if [ -z "$ver" ]; then
              echo "::warning::Could not resolve version for Alpine package: $pkg"
            fi
            echo "$ver"
          }

          OPENSSL_VER=$(fetch_apk_version openssl)
          OPENSSL_DEV_VER=$(fetch_apk_version openssl-dev)
          GIT_VER=$(fetch_apk_version git)
          CURL_VER=$(fetch_apk_version curl)
          BASH_VER=$(fetch_apk_version bash)
          GCC_VER=$(fetch_apk_version gcc)
          MUSL_VER=$(fetch_apk_version musl)
          LIBFFI_VER=$(fetch_apk_version libffi)
          MAKE_VER=$(fetch_apk_version make)
          BZIP2_VER=$(fetch_apk_version bzip2)
          ZLIB_VER=$(fetch_apk_version zlib)
          READLINE_VER=$(fetch_apk_version readline)
          SQLITE_VER=$(fetch_apk_version sqlite-dev)
          XZ_VER=$(fetch_apk_version xz)
          TK_VER=$(fetch_apk_version tk)
          PATCH_VER=$(fetch_apk_version patch)

          echo "openssl=$OPENSSL_VER"           >> $GITHUB_OUTPUT
          echo "openssl_dev=$OPENSSL_DEV_VER"   >> $GITHUB_OUTPUT
          echo "git=$GIT_VER"                   >> $GITHUB_OUTPUT
          echo "curl=$CURL_VER"                 >> $GITHUB_OUTPUT
          echo "bash=$BASH_VER"                 >> $GITHUB_OUTPUT
          echo "gcc=$GCC_VER"                   >> $GITHUB_OUTPUT
          echo "musl=$MUSL_VER"                 >> $GITHUB_OUTPUT
          echo "libffi=$LIBFFI_VER"             >> $GITHUB_OUTPUT
          echo "make=$MAKE_VER"                 >> $GITHUB_OUTPUT
          echo "bzip2=$BZIP2_VER"               >> $GITHUB_OUTPUT
          echo "zlib=$ZLIB_VER"                 >> $GITHUB_OUTPUT
          echo "readline=$READLINE_VER"         >> $GITHUB_OUTPUT
          echo "sqlite=$SQLITE_VER"             >> $GITHUB_OUTPUT
          echo "xz=$XZ_VER"                     >> $GITHUB_OUTPUT
          echo "tk=$TK_VER"                     >> $GITHUB_OUTPUT
          echo "patch=$PATCH_VER"               >> $GITHUB_OUTPUT

          echo "::endgroup::"
          echo "All versions resolved successfully."

      # ── Step 2: Use AI to apply the resolved versions to the Dockerfile ────
      - name: Apply updates via GitHub Models AI
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "::group::Preparing AI request"
          DOCKERFILE=$(cat Dockerfile)

          VERSIONS_SUMMARY="Resolved latest versions to apply:
          - DIND_VERSION: ${{ steps.versions.outputs.dind }}
          - UV_VERSION: ${{ steps.versions.outputs.uv }}
          - PYTHON_VERSIONS: ${{ steps.versions.outputs.python_versions }}
          - git: ${{ steps.versions.outputs.git }}
          - curl: ${{ steps.versions.outputs.curl }}
          - bash: ${{ steps.versions.outputs.bash }}
          - gcc: ${{ steps.versions.outputs.gcc }}
          - musl / musl-dev: ${{ steps.versions.outputs.musl }}
          - libffi / libffi-dev: ${{ steps.versions.outputs.libffi }}
          - make: ${{ steps.versions.outputs.make }}
          - openssl / openssl-dev: ${{ steps.versions.outputs.openssl }}
          - bzip2 / bzip2-dev: ${{ steps.versions.outputs.bzip2 }}
          - zlib / zlib-dev: ${{ steps.versions.outputs.zlib }}
          - readline / readline-dev: ${{ steps.versions.outputs.readline }}
          - sqlite-dev: ${{ steps.versions.outputs.sqlite }}
          - xz / xz-dev: ${{ steps.versions.outputs.xz }}
          - tk / tk-dev: ${{ steps.versions.outputs.tk }}
          - patch: ${{ steps.versions.outputs.patch }}"

          echo "$VERSIONS_SUMMARY"

          PAYLOAD=$(jq -n \
            --arg dockerfile "$DOCKERFILE" \
            --arg versions "$VERSIONS_SUMMARY" \
            '{
              model: "openai/gpt-4o",
              temperature: 0,
              max_tokens: 4096,
              messages: [
                {
                  role: "system",
                  content: "You are a Dockerfile editor. You receive a Dockerfile and a list of new package versions. You update the version pins in the Dockerfile to match the provided versions exactly. You output ONLY the raw updated Dockerfile — no markdown fences, no explanation, no extra text."
                },
                {
                  role: "user",
                  content: ("Update the following Dockerfile by replacing all version pins with the exact versions listed below. Do not change anything else.\n\n" + $versions + "\n\nDockerfile:\n\n" + $dockerfile)
                }
              ]
            }')
          echo "::endgroup::"

          echo "::group::Calling GitHub Models API"
          echo "Sending request to GitHub Models API..."
          RESPONSE=$(curl --max-time 120 --connect-timeout 30 -sS \
            -X POST "https://models.github.ai/inference/chat/completions" \
            -H "Authorization: Bearer $GH_TOKEN" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD")
          CURL_EXIT=$?

          if [ $CURL_EXIT -ne 0 ]; then
            echo "::error::curl failed with exit code $CURL_EXIT"
            exit 1
          fi

          if [ -z "$RESPONSE" ]; then
            echo "::error::API returned an empty response. Verify the GITHUB_TOKEN has models:read permission."
            exit 1
          fi
          echo "::endgroup::"

          echo "::group::Processing API response"
          if echo "$RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
            echo "::error::API error: $(echo "$RESPONSE" | jq -r '.error.message')"
            exit 1
          fi

          CONTENT=$(echo "$RESPONSE" | jq -r '.choices[0].message.content // empty')

          if [ -z "$CONTENT" ]; then
            FINISH_REASON=$(echo "$RESPONSE" | jq -r '.choices[0].finish_reason // "unknown"')
            echo "::error::Empty content received from API (finish_reason=$FINISH_REASON)"
            exit 1
          fi

          echo "Response received ($(printf '%s' "$CONTENT" | wc -l) lines)."

          # Extract Dockerfile content: if fenced, extract between first fence pair;
          # otherwise use the full response as-is (handles both cases without Python)
          if printf '%s\n' "$CONTENT" | grep -qE '^(```|~~~)'; then
            printf '%s\n' "$CONTENT" \
              | awk '/^(```|~~~)/{if(!found){found=1;next}else{exit}} found' > Dockerfile.new
          else
            printf '%s\n' "$CONTENT" > Dockerfile.new
          fi
          echo "::endgroup::"

          echo "::group::Validating updated Dockerfile"
          FROM_COUNT=$(grep -c '^FROM' Dockerfile.new 2>/dev/null || echo 0)
          LINE_COUNT=$(wc -l < Dockerfile.new)
          echo "Dockerfile.new: $LINE_COUNT lines, $FROM_COUNT FROM directives"

          if [ "$FROM_COUNT" -gt 0 ] && [ "$LINE_COUNT" -gt 3 ] && [ -s Dockerfile.new ]; then
            mv Dockerfile.new Dockerfile
            echo "Dockerfile updated successfully."
          else
            echo "::error::Response does not look like a valid Dockerfile (FROM directives: $FROM_COUNT, lines: $LINE_COUNT)."
            echo "First 10 lines of received content:"
            head -10 Dockerfile.new || true
            exit 1
          fi
          echo "::endgroup::"

          # Generate reasoning from the diff
          echo "::group::Generating change summary"
          DIFF=$(git diff Dockerfile)
          if [ -n "$DIFF" ]; then
            echo "Generating change summary (diff: $(printf '%s' "$DIFF" | wc -l) lines)..."
            REASONING_PAYLOAD=$(jq -n --arg diff "$DIFF" '{
              model: "openai/gpt-4o",
              temperature: 0,
              max_tokens: 512,
              messages: [{
                role: "user",
                content: ("Summarize in a short bullet list what version pins changed in this Dockerfile diff:\n\n" + $diff)
              }]
            }')
            curl --max-time 60 --connect-timeout 15 -sS \
              -X POST "https://models.github.ai/inference/chat/completions" \
              -H "Authorization: Bearer $GH_TOKEN" \
              -H "Content-Type: application/json" \
              -d "$REASONING_PAYLOAD" \
              | jq -r '.choices[0].message.content // "No reasoning available."' > agent_reasoning.txt
            echo "Change summary written to agent_reasoning.txt."
          else
            echo "No changes in Dockerfile." > agent_reasoning.txt
            echo "No version changes detected."
          fi
          echo "::endgroup::"

      # ── Step 3: Commit, push, open PR ──────────────────────────────────────
      - name: Check for changes
        id: check_changes
        run: |
          if [[ -n "$(git status --porcelain Dockerfile)" ]]; then
            echo "changes_exist=true" >> $GITHUB_ENV
            echo "Changes detected in Dockerfile."
          else
            echo "changes_exist=false" >> $GITHUB_ENV
            echo "No changes detected — Dockerfile is already up to date."
          fi

      - name: Commit and push branch
        if: env.changes_exist == 'true'
        run: |
          BRANCH_NAME="ai-dockerfile-update-$(date +%Y%m%d-%H%M)"
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git checkout -b "$BRANCH_NAME"
          git add Dockerfile
          git commit -m "chore(docker): AI proposed dependency updates"
          git push origin "$BRANCH_NAME"
          echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_ENV
          echo "Branch $BRANCH_NAME pushed successfully."

      - name: Create pull request
        if: env.changes_exist == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          REASONING=$(cat agent_reasoning.txt 2>/dev/null || echo "No reasoning available.")
          PR_BODY=$(cat <<EOF
          ## AI Dockerfile Dependency Update

          Automatically generated by the scheduled AI updater (GitHub Models / gpt-4o).
          Versions were resolved from upstream sources; AI applied them to the Dockerfile.

          ### Changes summary:
          ${REASONING}

          ---
          > Review the diff carefully before merging.
          EOF
          )

          gh pr create \
            --title "chore(docker): AI dependency updates ($(date +%Y-%m-%d))" \
            --body "$PR_BODY" \
            --base main \
            --head "${{ env.BRANCH_NAME }}"
